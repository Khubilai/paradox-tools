#!/usr/bin/env ruby

require_relative "../lib/paradox_mod_builder"

class CK2CustomScenario < ParadoxModBuilder
  def titles_to_clean_up
    # Do not destory papacy/patriarchy as they are important for game to function
    # Destroy caliphates as they are overly territorial and can be recreated quite easily
    @titles_to_clean_up ||= Set[*begin
      @game.glob("history/titles/[ek]_*.txt").map{|path|
        path.basename(".txt").to_s
      } - ["k_papal_state", "k_orthodox"] + ["d_sunni", "d_shiite"]
    end]
  end

  def no_kingdoms_empires_and_nomads!
    @game.glob("history/titles/*.txt").each do |path|
      title = path.basename(".txt").to_s
      if titles_to_clean_up.include?(title)
        patch_mod_file!(path) do |node|
          node.each do |date, attrs|
            attrs.delete "holder"
            attrs.delete "historical_nomad"
            attrs.delete "liege"
          end
          node.delete_if{|k,v| v.empty?}
        end
      else
        patch_mod_file!(path) do |node|
          node.each do |date, attrs|
            attrs.delete "historical_nomad"
            attrs.delete_if do |k,v|
              k == "liege" and titles_to_clean_up.include?(v)
            end
          end
          node.delete_if{|k,v| v.empty?}
        end
      end
    end
  end

  def no_wars!
    patch_mod_files!("history/wars/*.txt") do |node|
      node.delete_if{true}
    end
  end

  def deep_search(node, path=[], &blk)
    node.each do |key, val|
      if val.is_a?(PropertyList)
        deep_search(val, [*path, key], &blk)
      end
      yield(node, [*path, key])
    end
  end

  def landed_titles_lookup
    unless @landed_titles_lookup
      @landed_titles_lookup = {}
      landed_titles = parse("common/landed_titles/landed_titles.txt")
      deep_search(landed_titles) do |node, path|
        next unless path[-1] =~ /\A[cb]_/
        @landed_titles_lookup[path[-1]] = path.reverse
      end
    end
    @landed_titles_lookup
  end

  def setup_fun_province_religions!
    @title_religion = {}
    religion_map = {
      # Western Europe
      "e_spain"          => "catholic",
      "k_ireland"        => "catholic",
      "k_scotland"       => "catholic",
      "k_england"        => "lollard",
      "k_wales"          => "lollard",
      "k_portugal"       => "fraticelli",
      "k_andalusia"      => "fraticelli",
      "k_aquitaine"      => "cathar",
      "k_italy"          => "catholic",
      "e_france"         => "catholic",
      "k_frisia"         => "catholic",
      "k_venice"         => "catholic",

      # Scandinavia
      "e_scandinavia"    => "catholic",
      "d_iceland"        => "restore",
      "k_finland"        => "restore",
      "d_norrland"       => "restore",
      "d_trondelag"      => "restore",

      # Byzantine region
      "d_sicily"         => "orthodox",
      "k_byzantium"      => "orthodox",
      "k_anatolia"       => "orthodox",
      "k_georgia"        => "orthodox",
      "k_bulgaria"       => "bogomilist",
      "k_armenia"        => "miaphysite",
      "k_sicily"         => "restore",
      "d_armenia_minor"  => "miaphysite",
      "d_achaia"         => "hellenic_pagan",
      "k_dacia"          => "paulician",
      "k_serbia"         => "bogomilist",

      # Central Europe
      "k_bohemia"        => "waldensian",
      "d_bavaria"        => "waldensian",
      "d_osterreich"     => "waldensian",
      "k_lithuania"      => "baltic_pagan",
      "k_hungary"        => "tengri_pagan",
      "k_croatia"        => "catholic",
      "k_poland"         => "slavic_pagan",
      "d_pomeralia"      => "slavic_pagan",
      "d_pommerania"     => "slavic_pagan",
      "d_brandenburg"    => "slavic_pagan",
      "d_mecklemburg"    => "slavic_pagan",
      "k_germany"        => "catholic",
      "k_bavaria"        => "catholic",
      "k_lotharingia"    => "catholic",
      "d_saxony"         => "catholic",
      "d_meissen"        => "catholic",

      # Eastern Europe
      "k_perm"           => "restore",
      "k_volga_bulgaria" => "restore",
      "k_rus"            => "restore",
      "k_ruthenia"       => "restore",

      # Africa
      "k_egypt"          => "miaphysite",
      "k_africa"         => "sunni",
      "d_tlemcen"        => "kharijite",
      "d_alger"          => "kharijite",
      "d_kabylia"        => "kharijite",
      "e_mali"           => "west_african_pagan",
      "d_semien"         => "jewish",
      "d_harer"          => "hurufi",
      "d_afar"           => "hurufi",
      "e_abyssinia"      => "miaphysite",
      "c_canarias"       => "west_african_pagan",
      "d_fes"            => "yazidi",
      "d_marrakech"      => "zikri",
      "d_tangiers"       => "sunni",
      "d_cyrenaica"      => "monothelite",

      # Middle East
      "k_jerusalem"      => "jewish",
      "d_baghdad"        => "karaite",
      "d_oultrejourdain" => "samaritan",
      "d_tripoli"        => "monothelite",
      "d_damascus"       => "sunni",
      "d_syria"          => "druze",
      "d_jazira"         => "monophysite",

      # Arabia / Mesopotamia
      "d_basra"          => "shiite",
      "d_amman"          => "shiite",
      "d_tigris"         => "shiite",
      "d_sanaa"          => "shiite",
      "d_oman"           => "ibadi",
      "d_mosul"          => "nestorian",
      "c_socotra"        => "nestorian",
      "c_suwaida"        => "nestorian",
      "k_arabia"         => "sunni",
      "d_antioch"        => "orthodox",
      "d_aleppo"         => "orthodox",

      # Persia
      "k_persia"         => "zoroastrian",
      "k_baluchistan"    => "restore",
      "k_afghanistan"    => "zun_pagan",
      "k_khiva"          => "restore",
      "d_kermanshah"     => "shiite",
      "d_fars"           => "shiite",

      # Steppe
      # manichean goes here by restore
      "k_cumania"        => "tengri_pagan",
      "d_itil"           => "jewish",
      "k_khotan"         => "buddhist",
      "e_tartaria"       => "restore",

      # India
      # its mix of hindu/buddhist/jain is fairly sensible
      "e_rajastan"       => "restore",
      "e_deccan"         => "restore",
      "e_bengal"         => "restore",
      "d_sauvira"        => "hindu",
    }

    # These should maybe go somewhere:
    # * iconoclast (orthodox)
    # * messalian (nestorian)
    # * mazdaki (zoroastrian)
    # On the other hand they could just spawn via theology focus eventually

    patch_mod_files!("history/provinces/*.txt") do |node|
      titles = landed_titles_lookup[node["title"]]

      religion = titles.map{|t| religion_map[t] }.find(&:itself)
      unless religion
        actual = [node["religion"], *node.keys.grep(Date).map{|k| node[k]["religion"]}.compact]
        warn "No religion for #{titles.join(", ")} - #{actual.join(", ")}"
        next
      end

      # restore means just rollback to 769 whatever it was originally
      religion = node["religion"] if religion == "restore"

      holdings = [
        node["title"],
        *[node.keys + node.values.grep(PropertyList).map(&:keys)].flatten.grep(/\Ab_/),
      ]

      holdings.each do |h|
        @title_religion[h] = religion
      end

      node["religion"] = religion
      node.each do |key, val|
        next unless key.is_a?(Date)
        val.delete "religion"
      end
    end
  end

  def more_merchant_republics!
    # These will become cities, not all of them will become merchant republics,
    # only few of them with duke level holder
    provinces = [
      "802 - Alexandria",
      "468 - Ragusa",
      "858 - Aden",
      "868 - Muscat",
      "641 - Hormuz",
      "649 - Basra",
      "1297 - Debul",
      "1127 - Navasarika",
      "1114 - Mahoyadapuram",
      "1221 - Vijayawada",
      "1236 - Candradvipa",
      "158 - Porto",
      "78 - Brugge",
      "80 - Holland"
      # Would be nice, but not feudal:
      # "368 - Danzig",
      # "596 - Tana",
    ]
    provinces.each do |path|
      patch_mod_file!("history/provinces/#{path}.txt") do |node|
        # This is terribly hacky
        node.instance_eval do
          first_settlement = @list.index{|k,v| k=~/\Ab_/ }
          first_city       = @list.index{|k,v| k=~/\Ab_/ and v == "city"}
          first_castle     = @list.index{|k,v| k=~/\Ab_/ and v == "castle"}
          raise unless first_city and first_settlement == first_castle
          city = @list[first_city,1]
          @list[first_city,1]   = []
          @list[first_castle,0] = city
        end
      end
    end
  end

  def title_based_character_religion
    unless @title_based_character_religion
      character_religion = {}
      @game.glob("history/titles/*.txt").each do |path|
        title = path.basename(".txt").to_s
        node = parse(path)
        religion = @title_religion[title]

        unless religion
          # warn "Can't determine religion of title: #{title}"
          next
        end

        node.each do |date, events|
          next if events.empty?
          if events["holder"] and events["holder"] != 0
            id = events["holder"]
            character_religion[id] ||= Hash.new(0)
            character_religion[id][religion] += 1
          end
        end
      end

      @title_based_character_religion = {}
      character_religion.each do |id,stats|
        # Tie breaker by alphabet
        best_match = stats.keys.min_by{|k| [-stats[k], k]}
        @title_based_character_religion[id] = best_match
      end
    end
    @title_based_character_religion
  end

  def relations_to_hash(relations)
    ht = {}
    relations.each do |r1,r2,a,b|
      ht[a] ||= Hash.new(0)
      ht[a][b] += r1
      ht[b] ||= Hash.new(0)
      ht[b][a] += r2
    end
    ht
  end

  def relation_based_character_religion
    unless @relation_based_character_religion
      dynasties = {}
      relations = []
      @relation_based_character_religion = @title_based_character_religion.dup
      characters = []

      # Order of inference
      # * children from fathers
      # * children from mothers
      # * parents from children
      # * spouses
      # * employees
      @game.glob("history/characters/*.txt").each do |path|
        node = parse(path)
        node.each do |id, character|
          characters << id
          if character["dynasty"]
            (dynasties[character["dynasty"]] ||= []) << id
          end
          relations << [10000, 100, id, character["father"]] if character["father"]
          relations << [1000, 100, id, character["mother"]] if character["mother"]
          character.each do |key, val|
            next unless val.is_a?(PropertyList)
            relations << [10, 10, id, val["add_spouse"]] if val["add_spouse"]
            relations << [1, 0, id, val["employer"]] if val["employer"]
          end
        end
      end

      relations = relations_to_hash(relations)

      # Propagation time
      while true
        todo = characters - @relation_based_character_religion.keys
        changed = false
        # puts "Iteration: #{todo.size}"
        todo.each do |id|
          next unless relations[id]
          religion_inference = Hash.new(0)
          relations[id].each do |id2, rel|
            religion2 = @relation_based_character_religion[id2]
            next unless religion2
            religion_inference[religion2] += rel
          end
          next if religion_inference.empty?
          best_match = religion_inference.keys.min_by{|k| [-religion_inference[k],k] }
          @relation_based_character_religion[id] = best_match
          changed = true
        end
        break unless changed
      end

      # That does much less than expected
      dynasties.each do |_, dynasty|
        religion_inference = Hash.new(0)
        dynasty.each do |id|
          if @relation_based_character_religion[id]
            religion_inference[@relation_based_character_religion[id]] += 1
          end
        end
        next if religion_inference.empty?
        best_match = religion_inference.keys.min_by{|k| [-religion_inference[k],k] }
        dynasty.each do |id|
          @relation_based_character_religion[id] ||= best_match
        end
      end
      todo = characters - @relation_based_character_religion.keys
      # puts "Dynastic inference down to: #{todo.size}"
    end
    @relation_based_character_religion
  end

  def adjust_character_religions!
    patch_file!("history/characters/serbian.txt", force_create: true) do |content|
      content.sub("841.1.1.=", "841.1.1=")
    end

    # precompute for easier debugging
    title_based_character_religion
    relation_based_character_religion

    religions = Hash.new(0)
    patch_mod_files!("history/characters/*.txt") do |node|
      node.each do |id, character|
        # If we have nothing, just leave it as is. It's pobably semi-reasonable anyway
        if relation_based_character_religion[id]
          character["religion"] = relation_based_character_religion[id]
          character.each do |key, val|
            next unless val.is_a?(PropertyList)
            val.delete "religion"
          end
        end
        religions[character["religion"]] += 1
      end
    end
    # p religions
  end

  def build_mod_files!
    no_kingdoms_empires_and_nomads!
    no_wars!
    setup_fun_province_religions!
    more_merchant_republics!
    adjust_character_religions!
  end
end

mb = CK2CustomScenario.new(
  ParadoxGame.new(
    "source/ck2_2.4.3",
  ),
  "output/custom_scenario"
)
mb.build!
