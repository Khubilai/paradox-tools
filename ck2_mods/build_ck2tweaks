#!/usr/bin/env ruby

require_relative "../lib/paradox_mod_builder"

class CK2TweaksModBuilder < ParadoxModBuilder::CK2
  def reset_ruler_designer!
    patch_defines_lua!([
      # Start at 0 if you want to go down
      ["BASE_ATTRIB", 5, 5],
      ["BASE_AGE", 16, 16],
      ["BASE_FERTILITY", 0.5, 0.5],
      ["BASE_HEALTH", 5.0, 5.0],
      # Make everything free
      ["COST_ATTRIB", 1.0, 0],
      ["COST_SON", 3.0, 0],
      ["COST_DAUGHTER", 2.0, 0],
      ["COST_MARRIED", 2.0, 0],
      ["COST_FERTILITY", 20.0, 0],
      ["COST_HEALTH", 10.0, 0],
      ["COST_MONTHLY_PRESTIGE", 10.0, 0],
      ["COST_MONTHLY_PIETY", 20.0, 0],
      ["COST_MONTHLY_WEALTH", 10.0, 0],
      ["COST_GLOBAL_TAX", 50.0, 0],
      ["COST_CHURCH_OPINION", 0.5, 0],
      ["COST_SPOUCE_OPINION", 0.5, 0],
      ["COST_SEXAPPEAL_OPINION", 0.5, 0],
      ["COST_DYNASTY_OPINION", 0.5, 0],
      ["COST_VASSAL_OPINION", 1.0, 0],
      ["COST_LIEGE_OPINION", 0.0, 0],
      ["COST_INFIDEL_OPINION", 0.0, 0],
      ["COST_OPPOSITE_TRAIT_OPINION", 0.5, 0],
      ["COST_SAME_TRAIT_OPINION", 0.5, 0],
      ["COST_SAME_RELIGION_OPINION", 0.5, 0],
      ["COST_AMBITION_OPINION", 0.0, 0],
      ["COST_TRIBAL_OPINION", 0.0, 0],
      ["COST_GENERAL_OPINION", 1.0, 0],
      ["COST_MUSLIM_OPINION", 0.25, 0],
      ["COST_JEWISH_OPINION", 0.25, 0],
      ["COST_CHRISTIAN_OPINION", 0.25, 0],
      ["COST_ZOROASTRIAN_OPINION", 0.25, 0],
      ["COST_MORALE_OFFENCE", 50.0, 0],
      ["COST_MORALE_DEFENCE", 50.0, 0],
      ["COST_DEFENCE", 50.0, 0],
      # Max age is irrelevant as all is now 16
      ["MAX_AGE", 50, 50],
    ])
  end

  def fix_gavelkind!
    # Bonus is not applied correctly and is far less than 30% claimed
    # Increase it to balance things out a bit
    patch_defines_lua!([
      ["GAVELKIND_MAX_SIZE_BONUS", "0.30", "0.50"],
    ])
  end

  def reduce_wrong_gov_type_penalties!
    # This punishes feudalizing tribals way too much
    patch_defines_lua!([
      ["WRONG_GOV_FORM_TAX_MOD", -0.75, -0.50],
      ["WRONG_GOV_FORM_LEVY_MOD", -0.75, -0.50],
    ])
  end

  def allow_any_number_of_different_holding_types!
    # A nerf without exploit
    patch_defines_lua!([
      ["MAX_REPUBLIC_COUNTIES_IN_REALM", 0.1, 1.0],
      ["MAX_THEOCRACY_COUNTIES_IN_REALM", 0.1, 1.0],
    ])
  end

  def take_money_from_banished_landed_characters!
    # That's not even particularly gamey
    patch_defines_lua!([
      ["BANISH_TAKE_WEALTH_PERCENTAGE_LANDED", 0, 1],
    ])
  end

  def remove_levy_nerfs!
    # This break feudal character of the game
    patch_defines_lua!([
      ["REBEL_LEADER_MINIMUM_LIEGE_LEVY_MULT",  1,     1],
      ["CAPITAL_COUNTY_VASSAL_COUNT_LEVY_MULT", 1,     1],
      ["CAPITAL_COUNTY_VASSAL_LEVY_MULT",       1.25,  1],
      ["CAPITAL_COUNTY_LEVY_MULT",              1.5,   1],
      ["CAPITAL_COUNTY_LIEGE_LEVY_MULT",        1,     1],
      ["CAPITAL_DUCHY_VASSAL_LEVY_MULT",        1.15,  1],
      ["CAPITAL_DUCHY_LEVY_MULT",               1.25,  1],
      ["CAPITAL_DUCHY_LIEGE_LEVY_MULT",         0.75,  1],
      ["CAPITAL_KINGDOM_LEVY_MULT",             1,     1],
      ["CAPITAL_KINGDOM_LIEGE_LEVY_MULT",       0.5,   1],
      ["CAPITAL_EMPIRE_LEVY_MULT",              1,     1],
      ["CAPITAL_EMPIRE_LIEGE_LEVY_MULT",        0.35,  1],
      ["OUTSIDE_LEVY_MULT",                     1,     1],
      ["OUTSIDE_LIEGE_LEVY_MULT",               0.25,  1],
    ])
  end

  def no_dynastic_country_names!
    patch_mod_files!("common/cultures/*.txt") do |node|
      node.each do |group_name, group|
        group.each do |culture_name, culture|
          next if culture_name == "graphical_culture"
          next if culture_name == "second_graphical_culture"
          culture.delete("dynasty_title_names")
        end
      end
    end
  end

  def allow_intermarriage!
    patch_mod_file!("common/religions/00_religions.txt") do |node|
      all_religions = node.values.map{|group| group.list.select{|_,r| r.is_a?(PropertyList)}.map(&:first)}.flatten
      node.each do |group_name, group|
        group.each do |religion_name, religion|
          next unless religion.is_a?(PropertyList)
          religion.delete("intermarry")
          all_religions.each do |g|
            religion.add! "intermarry", g unless g == religion_name
          end
        end
      end
    end
  end

  def allow_heir_designation!
    patch_mod_file!("common/religions/00_religions.txt") do |node|
      node.each do |group_name, group|
        next if group_name == "muslim"
        group.each do |religion_name, religion|
          next unless religion.is_a?(PropertyList)
          religion["has_heir_designation"] = true
        end
      end
    end
  end

  def pagans_can_go_feudal!
    # Otherwise AI never will
    patch_mod_file!("decisions/realm_decisions.txt") do |node|
      %W[
        convert_to_feudalism_indep
        convert_to_feudalism_vassal
        convert_to_republic_indep
      ].each do |decision|
        node["decisions"][decision]["allow"].delete_if{|k,v| k == "custom_tooltip"}
      end
    end
  end

  def more_banishment_reasons!
    patch_mod_file!("common/opinion_modifiers/00_opinion_modifiers.txt") do |node|
      %W[
        opinion_traitor
        opinion_rebel_traitor
        opinion_regicide_traitor
        opinion_witch
        opinion_unfaithful_wife
        opinion_cuckolded
        opinion_charge_illegitimate
        opinion_charge_traitor
      ].each do |op|
        node[op].add! "banish_reason", true
      end
    end
  end

  def add_dynastic_decisions!
    # All these should be filtered etc.
    # Extremely basic functionality only
    decisions = PropertyList[
      "switch_to_spouse_dynasty", PropertyList[
        "filter", "spouse",
        "ai_target_filter", "spouse",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList["is_married", "FROM"],
        "allow", PropertyList["age", 16],
        "effect", PropertyList["FROM", PropertyList["dynasty", "ROOT"]],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ],
      "make_marriage_regular", PropertyList[
        "filter", "spouse",
        "ai_target_filter", "spouse",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList["is_married", "FROM"],
        "allow", PropertyList["age", 16],
        "effect", PropertyList["FROM", PropertyList["add_spouse", "ROOT"]],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ],
      "make_marriage_matrilineal", PropertyList[
        "filter", "spouse",
        "ai_target_filter", "spouse",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList["is_married", "FROM"],
        "allow", PropertyList["age", 16],
        "effect", PropertyList["FROM", PropertyList["add_spouse_matrilineal", "ROOT"]],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ],
      "educate_kin", PropertyList[
        "filter", "dynasty",
        "ai_target_filter", "dynasty",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList[
          "age", 6,
          Property::NOT["age", 16],
        ],
        # "allow", PropertyList[
          # "is_close_relative", "ROOT",
          # Property::NOT["guardian", "ROOT"],
        # ],
        "effect", PropertyList["set_guardian", "FROM"],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ]
    ]

    create_mod_file! "decisions/dynastic_decisions.txt", PropertyList["targetted_decisions", decisions]
    localization!("dynastic_decisions",
      "switch_to_spouse_dynasty" => "Swich to spouse's dynasty",
      "switch_to_spouse_dynasty_desc" => "Abandon your current family name, become part of spouse's dynasty",
      "make_marriage_regular" => "Make marriage regular",
      "make_marriage_regular_desc" => "All children will by of father's dynasty",
      "make_marriage_matrilineal" => "Make marriage matrilineal",
      "make_marriage_matrilineal_desc" => "All children will by of mother's dynasty",
      "educate_kin" => "Educate close kin",
      "educate_kin_desc" => "Can use even if beyond education limit",
    )
  end

  def cognatic_for_most_cultures!
    patch_mod_file!("common/laws/succession_laws.txt") do |node|
      node["gender_laws"]["true_cognatic_succession"].delete("allow")
    end
  end

  def setup_sensible_imporatnt_decisions_list!
    patch_mod_files!("decisions/*.txt") do |node|
      node.each do |category, decisions|
        next unless category == "decisions"
        decisions.each do |name, decision|
          time_specific  = !!(decision["allow"].to_s =~ /month|war/)
          focus_specific = !!(decision["potential"].to_s =~ /has_focus/)

          if ["ask_help_to_manage_titles", "conscript_merchant_ships"].include?(name)
            decision.delete "is_high_prio"
          elsif ["welcome_jews", "expel_jews", "borrow_money_jews"].include?(name) or
                time_specific or focus_specific
            decision.add! "is_high_prio", true
          elsif decision["is_high_prio"]
            # The rest are OK
          else
            # The rest are OK
          end
        end
      end
    end
  end

  def preserve_culture_buildings!
    patch_mod_files!("common/buildings/*.txt") do |node|
      node.each do |category, buildings|
        buildings.each do |name, building|
          next unless building["potential"] and building["potential"]["FROM"].to_s =~ /culture/
          culture_rules = building["potential"]["FROM"]
          building["potential"].delete "FROM"
          building["potential"].add! Property::OR[
            "FROM", culture_rules,
            *culture_rules.list.flatten(1), # This is some awkward code...
            "FROMFROM", PropertyList["has_building", name],
          ]
        end
      end
    end
  end

  def tribal_buildings_for_prestige!
    patch_mod_files!("common/buildings/*.txt") do |node|
      node.each do |category, buildings|
        next unless category == "tribal"
        buildings.each do |name, building|
          if building["gold_cost"] and not building["port"]
            building.add! "prestige_cost", building["gold_cost"] * 2
            building.delete "gold_cost"
          elsif building["prestige_cost"]
            building["prestige_cost"] /= 2
          end
        end
      end
    end
  end

  # It is just ridiculously slow. This is probably too much, but worth trying.
  def faster_culture_conversion!
    patch_mod_file!("events/culture_conversion_events.txt") do |node|
      node.find_all("province_event").each do |event|
        next unless event["id"] == 55000 or event["id"] == 55001
        event["mean_time_to_happen"]["months"] /= 10
      end
    end
  end

  def fast_de_jure_drift!
    patch_defines_lua!([
      ["DE_JURE_ASSIMILATION_YEARS", 100, 50],
      ["EMPIRE_DE_JURE_ASSIMILATION_YEARS", 100, 20],
    ])
  end

  def seduce_any_religion!
    patch_mod_file!("decisions/way_of_life_decisions.txt") do |node|
      node["targetted_decisions"]["seduce_decision"]["allow"].delete "religion_group"
    end
  end

  # Crashes the game, would be interesting to debug
  def create_hunie_events!
    # All hunies are attractive
    # All hunies >16 are lustful
    create_mod_file! "events/hunie_events.txt", PropertyList[
      "character_event", PropertyList[
        "id", "hunie.001",
        "desc", "hunie.001desc",
        "picture", "GFX_evt_lovers",
        "border", "GFX_event_normal_frame_intrigue",
        "trigger", PropertyList[
          "trait", "hunie",
          "NOT", PropertyList["trait", "fair"],
        ],
        "mean_time_to_happen", PropertyList["months", 0],
        "option", PropertyList[
          "name", "hunie.001a",
          "add_trait", "fair",
        ],
      ],
      "character_event", PropertyList[
        "id", "hunie.002",
        "desc", "hunie.002desc",
        "picture", "GFX_evt_lovers",
        "border", "GFX_event_normal_frame_intrigue",
        "trigger", PropertyList[
          "trait", "hunie",
          "age", 16,
          "NOT", PropertyList["trait", "lustful"],
        ],
        "mean_time_to_happen", PropertyList["months", 0],
        "option", PropertyList[
          "name", "hunie.002a",
          "add_trait", "lustful",
        ],
      ],
    ]
    localization!("hunie_events",
      "hunie.001" => "Hunies are all cute",
      "hunie.001desc" => "You can't be a Hunie if you're not cute",
      "hunie.001a" => "So I'll be cute",
      "hunie.002" => "Hunies are all lustful",
      "hunie.002desc" => "You can't be a Hunie if you're not lustful",
      "hunie.002a" => "So I'll be lustful",
    )
  end

  def hunie_can_always_seduce!(node)
    fix_node = false # Do this after fixing children
    node.each do |key, val|
      if key == "has_focus" and val == "focus_seduction"
        fix_node = true
      end
      hunie_can_always_seduce!(val) if val.is_a?(PropertyList)
    end
    if fix_node
      # More complex patching but generates better looking diffs
      # Maybe this should get API too?
      i = node.list.index{|key,val| key == "has_focus" and val == "focus_seduction"}
      node.instance_eval{@list}[i] = ["OR", PropertyList[
        "has_focus", "focus_seduction",
        "trait", "hunie",
      ]]
    end
  end

  def create_hunie_trait!
    create_mod_file! "common/traits/99_hunie_traits.txt", PropertyList[
      "hunie", PropertyList[
        # "cannot_marry", true,
        # "fertility", 0.5,
        "sex_appeal_opinion", 30,
        "inherit_chance", 100,
      ],
    ]
    create_mod_file! "interface/hunie.gfx", PropertyList[
      "spriteTypes", PropertyList[
        "spriteType", PropertyList[
          "name", "GFX_trait_hunie",
          "texturefile", "gfx/traits/seductress.tga",
          "noOfFrames", 1,
          "norefcount", true,
          "effectFile", "gfx/FX/buttonstate.lua",
        ],
      ],
    ]
    localization!("hunie_trait",
      "hunie" => "Hunie",
      "hunie_desc" => "The character cannot marry and will forever date casually instead",
    )
    # Hunies can't marry, so being pregnant while not married is just fine
    patch_mod_file!("events/birth_events.txt") do |node|
      event = node.find_all("character_event").find{|ev| ev["id"] == 401}
      #event["trigger"].add! "NOT", PropertyList["trait", "hunie"]
      event["option"].delete "piety"
      event["option"].delete "prestige"
      event["option"].add! "if", PropertyList[
        "limit", PropertyList["NOT", PropertyList["trait", "hunie"]],
        "piety", -50,
        "prestige", -50,
      ]
    end
    # Hunies can seduce by their nature, so they can focus on anything they want
    # It could just mod everything in decisions/* and events/*
    %W[
      decisions/way_of_life_decisions.txt
      events/birth_events.txt
      events/wol_lover_events.txt
      events/wol_seduction_events.txt
    ].each do |path|
      patch_mod_file!(path) do |node|
        hunie_can_always_seduce!(node)
      end
    end
  end

  def no_russian!
    # Keep 3 separate East Slavic cultures
    patch_mod_file!("events/cm_culture_conversion_events.txt") do |node|
      node.delete_if{|key, val| key == "province_event" and val["id"] == "CM.11"}
    end
  end

  # Better fix would be make it something that happens sometimes, not every damn time
  def disable_abandon_iconoclasm_for_ai!
    patch_mod_file!("decisions/conversion_decisions.txt") do |node|
      node["decisions"]["renounce_iconoclasm"]["ai_will_do"]["factor"] = 0
    end
  end

  def king_level_titles
    @king_level_titles ||= begin
      titles  = @game.parse("common/landed_titles/landed_titles.txt")
      empires = titles.keys.grep(/\Ae_/)
      [titles, *empires.map{|e| titles[e]}].map(&:keys).flatten(1).grep(/\Ak_/).sort
    end
  end

  # Transferring vassal dukes under vassal kings is broken
  # Don't setup any other transfers as that's unnecessary
  # Can't handle custom titles etc.
  def setup_vassal_transfer!
    decisions = []
    # FROM - emperor
    # ROOT - duke vassal
    # PREV - king vassal (within holder_scope)
    king_level_titles.each do |k_title|
      # Oops, localization system doesn't support CK2 yet, just EU4 :-/
      # Anyway, there's probably some way to make it work with %codes% instead
      k_title_loc = k_title.sub(/\Ak_/, "").split("_").map(&:capitalize).join(" ")

      decisions << Property[
        "transfer_vassal_under_#{k_title}", PropertyList[
          "filter", "vassals",
          "ai_target_filter", "vassals",
          "from_potential", PropertyList[
            "tier", "emperor",
            "any_vassal", PropertyList["has_landed_title", k_title],
          ],
          "potential", PropertyList[
            "tier", "duke",
          ],
          "allow", PropertyList[
            "tier", "duke",
            "liege", PropertyList["character", "FROM"],
            # Neighbouring vassal king
            "any_realm_province", PropertyList[
              "any_neighbor_province", PropertyList[
                "has_owner", true,
                "holder_scope", PropertyList[
                  "OR", PropertyList[
                    "has_landed_title", k_title,
                    "any_liege", PropertyList["has_landed_title", k_title],
                  ],
                ],
              ],
            ],
          ],
          "effect", PropertyList[
            k_title, PropertyList[
              "holder_scope", PropertyList[
                "ROOT", PropertyList[
                  "set_defacto_liege", "PREV",
                ],
                "opinion", PropertyList[
                  "modifier", "opinion_vassal_transfer",
                  "who", "liege",
                  "months", 120,
                ],
              ],
            ],
          ],
          "revoke_allowed", PropertyList["always", false],
          "ai_will_do", PropertyList["factor", 0],
        ],
      ]
      localization!("vassal_transfer_decisions",
        "transfer_vassal_under_#{k_title}" => "Transfer under #{k_title_loc}",
        "transfer_vassal_under_#{k_title}_desc" => "Make duke vassal of #{k_title_loc} instead of you directly",
      )
    end

    create_mod_file! "decisions/vassal_transfer_decisions.txt", PropertyList["targetted_decisions", PropertyList[*decisions]]
  end

  # As high as allowed by your technology
  def setup_sensible_ai_for_demesne_laws!
    patch_mod_file!("common/laws/demesne_laws.txt") do |node|
      laws_to_fix = %W[
        feudal_contract
        feudal_tax
        city_contract
        city_tax
        temple_contract
        temple_tax
        iqta_contract
        iqta_tax
      ]
      laws_to_fix.each do |law|
        node["laws"]["#{law}_0"]["ai_will_do"] = PropertyList[
          "factor", 0,
        ]
        node["laws"]["#{law}_1"]["ai_will_do"] = PropertyList[
          "factor", 1,
          "modifier", PropertyList["factor", 0, "has_law", "#{law}_2"],
          "modifier", PropertyList["factor", 0, "has_law", "#{law}_3"],
        ]
        node["laws"]["#{law}_2"]["ai_will_do"] = PropertyList[
          "factor", 1,
          "modifier", PropertyList["factor", 0, "has_law", "#{law}_3"],
        ]
        node["laws"]["#{law}_3"]["ai_will_do"] = PropertyList[
          "factor", 1,
        ]
      end
    end
  end

  def allow_everyone_river_access!
    patch_mod_file!("common/religions/00_religions.txt") do |node|
      node.each do |group_name, group|
        group.each do |religion_name, religion|
          next unless religion.is_a?(PropertyList)
          religion["allow_rivermovement"] = true
        end
      end
    end
  end

  def disable_fucking_hints!
    patch_mod_file!("common/hints.txt") do |node|
      node.each do |name, hint|
        hint.delete "sticky"
      end
    end
  end

  # Because it's a portage, only use with allow_everyone_river_access!
  def suez_canal!
    # 1382 - Gulf of Suez
    #  939 - Nile Delta
    #  789 - Pelusia
    patch_file!("map/adjacencies.csv", reencode: "iso-8859-1") do |content|
      [
        content,
        "939;1382;portage;789;-1;-1;-1;-1;Suez Canal",
      ].join("\r\n")
    end
    # Merge both oceans
    patch_mod_file!("map/default.map") do |map|
      map.delete_if{|k,v|
        k == "ocean_region" and v == PropertyList["sea_zones", [5, 6, 7, 8]]
      }
      map["ocean_region"]["sea_zones"] = [1,2,3,4,5,6,7,8]
    end
  end

  def build_mod_files!
    ### General fixes:
    no_dynastic_country_names!
    allow_any_number_of_different_holding_types!
    allow_intermarriage!
    allow_heir_designation!
    fix_gavelkind!
    reset_ruler_designer!
    reduce_wrong_gov_type_penalties!
    seduce_any_religion!
    cognatic_for_most_cultures!
    preserve_culture_buildings!
    pagans_can_go_feudal!
    add_dynastic_decisions!
    setup_sensible_imporatnt_decisions_list!
    setup_vassal_transfer!
    setup_sensible_ai_for_demesne_laws!
    fast_de_jure_drift!
    allow_everyone_river_access!
    disable_fucking_hints!
    suez_canal!

    ### Specific things for specific campaign, kept for reference:
    # create_hunie_trait!
    # no_russian!
    # disable_abandon_iconoclasm_for_ai!
    # faster_culture_conversion!

    # remove_levy_nerfs!

    ### Completely obsolete in new patch
    ### (not sure if new banishment system is good or bad)
    # tribal_buildings_for_prestige!
    # take_money_from_banished_landed_characters!
    # more_banishment_reasons!
  end
end

mb = CK2TweaksModBuilder.new(
  ParadoxGame.new(
    "source/ck2_2.4.1",
  ),
  "output/ck2tweaks"
)
mb.build!
