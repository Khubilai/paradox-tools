#!/usr/bin/env ruby

require_relative "../lib/paradox_mod_builder"

class CK2TweaksModBuilder < ParadoxModBuilder
  # Move to base?
  def override_defines_lua!(name, overrides)
    create_file!(
      "common/defines/#{name}.lua",
      overrides.map{|key, val| "NDefines.#{key} = #{val}\n"}.join
    )
  end

  def reset_ruler_designer!
    keys  = %W[
      COST_ATTRIB
      COST_SON
      COST_DAUGHTER
      COST_MARRIED
      COST_FERTILITY
      COST_HEALTH
      COST_MONTHLY_PRESTIGE
      COST_MONTHLY_PIETY
      COST_MONTHLY_WEALTH
      COST_GLOBAL_TAX
      COST_CHURCH_OPINION
      COST_SPOUCE_OPINION
      COST_SEXAPPEAL_OPINION
      COST_DYNASTY_OPINION
      COST_VASSAL_OPINION
      COST_LIEGE_OPINION
      COST_INFIDEL_OPINION
      COST_OPPOSITE_TRAIT_OPINION
      COST_SAME_TRAIT_OPINION
      COST_SAME_RELIGION_OPINION
      COST_AMBITION_OPINION
      COST_TRIBAL_OPINION
      COST_UNREFORMED_TRIBAL_OPINION
      COST_GENERAL_OPINION
      COST_MUSLIM_OPINION
      COST_JEWISH_OPINION
      COST_CHRISTIAN_OPINION
      COST_ZOROASTRIAN_OPINION
      COST_MORALE_OFFENCE
      COST_MORALE_DEFENCE
      COST_DEFENCE
    ]
    # Keep BASE_*, MAX_AGE
    override_defines_lua!("ruler_designer",
      Hash[keys.map{|key| ["NRulerDesigner.#{key}", 0] }]
    )
    patch_mod_files!("common/traits/*.txt") do |node|
      node.each do |name, trait|
        trait.delete "ruler_designer_cost"
      end
    end
  end

  def fix_gavelkind!
    # Bonus is not applied correctly and is far less than 30% claimed
    # Increase it to balance things out a bit
    override_defines_lua!("gavelkind",
      "NDiplomacy.GAVELKIND_MAX_SIZE_BONUS" => "0.50"
    )
  end

  def no_multiple_empires!
    # This is AI dumb
    override_defines_lua!("no_multiple_empire",
      "NAI.MAX_EMPIRE_TITLES_TO_CREATE" => 1,
    )
  end

  def reduce_wrong_gov_type_penalties!
    # This punishes feudalizing tribals way too much
    override_defines_lua!("wrong_gov_type",
      "NCharacter.WRONG_GOV_FORM_TAX_MOD"  => -0.50,
      "NCharacter.WRONG_GOV_FORM_LEVY_MOD" => -0.50,
    )
  end

  def allow_any_number_of_different_holding_types!
    # A nerf without exploit
    override_defines_lua!("max_counties_in_realm",
      "NTitle.MAX_REPUBLIC_COUNTIES_IN_REALM"  => 1.0,
      "NTitle.MAX_THEOCRACY_COUNTIES_IN_REALM" => 1.0,
    )
  end

  def disable_diplomatic_range_limit!
    override_defines_lua!("diplomatic_distance",
      "NDiplomacy.MAX_DIPLO_DISTANCE" => 10000,
    )
  end

  def remove_levy_nerfs!
    # This break feudal character of the game
    override_defines_lua!("levy_nerf",
      "NMilitary.REBEL_LEADER_MINIMUM_LIEGE_LEVY_MULT"  => 1,
      "NMilitary.CAPITAL_COUNTY_VASSAL_COUNT_LEVY_MULT" => 1,
      "NMilitary.CAPITAL_COUNTY_VASSAL_LEVY_MULT"       => 1,
      "NMilitary.CAPITAL_COUNTY_LEVY_MULT"              => 1,
      "NMilitary.CAPITAL_COUNTY_LIEGE_LEVY_MULT"        => 1,
      "NMilitary.CAPITAL_DUCHY_VASSAL_LEVY_MULT"        => 1,
      "NMilitary.CAPITAL_DUCHY_LEVY_MULT"               => 1,
      "NMilitary.CAPITAL_DUCHY_LIEGE_LEVY_MULT"         => 1,
      "NMilitary.CAPITAL_KINGDOM_LEVY_MULT"             => 1,
      "NMilitary.CAPITAL_KINGDOM_LIEGE_LEVY_MULT"       => 1,
      "NMilitary.CAPITAL_EMPIRE_LEVY_MULT"              => 1,
      "NMilitary.CAPITAL_EMPIRE_LIEGE_LEVY_MULT"        => 1,
      "NMilitary.OUTSIDE_LEVY_MULT"                     => 1,
      "NMilitary.OUTSIDE_LIEGE_LEVY_MULT"               => 1,
    )
  end

  def no_dynastic_country_names!
    patch_mod_files!("common/cultures/*.txt") do |node|
      node.each do |group_name, group|
        group.each do |culture_name, culture|
          next if culture_name == "graphical_culture"
          next if culture_name == "second_graphical_culture"
          culture.delete("dynasty_title_names")
        end
      end
    end
  end

  def allow_intermarriage!
    patch_mod_file!("common/religions/00_religions.txt") do |node|
      religion_groups = node.keys
      node.each do |group_name, group|
        group.each do |religion_name, religion|
          next unless religion.is_a?(PropertyList)
          religion.delete("intermarry")
          religion_groups.each do |g|
            religion.add! "intermarry", g
          end
        end
      end
    end
  end

  def allow_heir_designation!
    patch_mod_file!("common/religions/00_religions.txt") do |node|
      node.each do |group_name, group|
        next if group_name == "muslim"
        group.each do |religion_name, religion|
          next unless religion.is_a?(PropertyList)
          religion["has_heir_designation"] = true
        end
      end
    end
  end

  def pagans_can_go_feudal!
    # Otherwise AI never will
    patch_mod_file!("decisions/realm_decisions.txt") do |node|
      %W[
        convert_to_feudalism_indep
        convert_to_feudalism_vassal
        convert_to_republic_indep
      ].each do |decision|
        node["decisions"][decision]["allow"].delete_if{|k,v| k == "custom_tooltip"}
      end
    end
  end

  def more_banishment_reasons!
    patch_mod_file!("common/opinion_modifiers/00_opinion_modifiers.txt") do |node|
      %W[
        opinion_traitor
        opinion_rebel_traitor
        opinion_regicide_traitor
        opinion_witch
        opinion_unfaithful_wife
        opinion_cuckolded
        opinion_charge_illegitimate
        opinion_charge_traitor
      ].each do |op|
        node[op].add! "banish_reason", true
      end
    end
  end

  def add_dynastic_decisions!
    # All these should be filtered etc.
    # Extremely basic functionality only
    decisions = PropertyList[
      "switch_to_spouse_dynasty", PropertyList[
        "filter", "spouse",
        "ai_target_filter", "spouse",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList["is_married", "FROM"],
        "allow", PropertyList["age", 16],
        "effect", PropertyList["FROM", PropertyList["dynasty", "ROOT"]],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ],
      "make_marriage_regular", PropertyList[
        "filter", "spouse",
        "ai_target_filter", "spouse",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList["is_married", "FROM"],
        "allow", PropertyList["age", 16],
        "effect", PropertyList["FROM", PropertyList["add_spouse", "ROOT"]],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ],
      "make_marriage_matrilineal", PropertyList[
        "filter", "spouse",
        "ai_target_filter", "spouse",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList["is_married", "FROM"],
        "allow", PropertyList["age", 16],
        "effect", PropertyList["FROM", PropertyList["add_spouse_matrilineal", "ROOT"]],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ],
      "educate_kin", PropertyList[
        "filter", "dynasty",
        "ai_target_filter", "dynasty",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList[
          "age", 6,
          Property::NOT["age", 16],
        ],
        # "allow", PropertyList[
          # "is_close_relative", "ROOT",
          # Property::NOT["guardian", "ROOT"],
        # ],
        "effect", PropertyList["set_guardian", "FROM"],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ]
    ]

    create_mod_file! "decisions/dynastic_decisions.txt", PropertyList["targetted_decisions", decisions]
    localization!("dynastic_decisions",
      "switch_to_spouse_dynasty" => "Swich to spouse's dynasty",
      "switch_to_spouse_dynasty_desc" => "Abandon your current family name, become part of spouse's dynasty",
      "make_marriage_regular" => "Make marriage regular",
      "make_marriage_regular_desc" => "All children will by of father's dynasty",
      "make_marriage_matrilineal" => "Make marriage matrilineal",
      "make_marriage_matrilineal_desc" => "All children will by of mother's dynasty",
      "educate_kin" => "Educate close kin",
      "educate_kin_desc" => "Can use even if beyond education limit",
    )
  end

  def cognatic_for_most_cultures!
    patch_mod_file!("common/laws/succession_laws.txt") do |node|
      node["gender_laws"]["true_cognatic_succession"].delete("allow")
    end
  end

  def setup_sensible_imporatnt_decisions_list!
    patch_mod_files!("decisions/*.txt") do |node|
      node.each do |category, decisions|
        next unless category == "decisions"
        decisions.each do |name, decision|
          time_specific  = !!(decision["allow"].to_s =~ /month|war/)
          focus_specific = !!(decision["potential"].to_s =~ /has_focus/)

          if ["ask_help_to_manage_titles", "conscript_merchant_ships"].include?(name)
            decision.delete "is_high_prio"
          # expel_jews/borrow_money_jews are available all time and no longer that OP
          # welcome_jews is time specific
          elsif ["welcome_jews"].include?(name) or time_specific or focus_specific
            decision.add! "is_high_prio", true
          elsif decision["is_high_prio"]
            # The rest are OK
          else
            # The rest are OK
          end
        end
      end
    end
  end

  def preserve_culture_buildings!
    patch_mod_files!("common/buildings/*.txt") do |node|
      node.each do |category, buildings|
        buildings.each do |name, building|
          next unless building["potential"] and building["potential"]["FROM"].to_s =~ /culture/
          culture_rules = building["potential"]["FROM"]

          if culture_rules.size == 1
            province_rule = Property[*culture_rules.list[0]]
          else
            province_rule = Property::AND[*culture_rules.list.flatten(1)]
          end

          building["potential"].delete "FROM"
          building["potential"].add! Property::OR[
            "FROM", culture_rules,
            province_rule,
            "FROMFROM", PropertyList["has_building", name],
          ]
        end
      end
    end
  end

  def fast_de_jure_drift!
    override_defines_lua!("de_jure_drift",
      "NTitle.DE_JURE_ASSIMILATION_YEARS" => 50,
      "NTitle.EMPIRE_DE_JURE_ASSIMILATION_YEARS" => 20,
    )
  end

  def seduce_any_religion!
    patch_mod_file!("decisions/way_of_life_decisions.txt") do |node|
      node["targetted_decisions"]["seduce_decision"]["allow"].delete "religion_group"
    end
  end

  # Crashes the game, would be interesting to debug
  def create_hunie_events!
    # All hunies are attractive
    # All hunies >16 are lustful
    create_mod_file! "events/hunie_events.txt", PropertyList[
      "character_event", PropertyList[
        "id", "hunie.001",
        "desc", "hunie.001desc",
        "picture", "GFX_evt_lovers",
        "border", "GFX_event_normal_frame_intrigue",
        "trigger", PropertyList[
          "trait", "hunie",
          "NOT", PropertyList["trait", "fair"],
        ],
        "mean_time_to_happen", PropertyList["months", 0],
        "option", PropertyList[
          "name", "hunie.001a",
          "add_trait", "fair",
        ],
      ],
      "character_event", PropertyList[
        "id", "hunie.002",
        "desc", "hunie.002desc",
        "picture", "GFX_evt_lovers",
        "border", "GFX_event_normal_frame_intrigue",
        "trigger", PropertyList[
          "trait", "hunie",
          "age", 16,
          "NOT", PropertyList["trait", "lustful"],
        ],
        "mean_time_to_happen", PropertyList["months", 0],
        "option", PropertyList[
          "name", "hunie.002a",
          "add_trait", "lustful",
        ],
      ],
    ]
    localization!("hunie_events",
      "hunie.001" => "Hunies are all cute",
      "hunie.001desc" => "You can't be a Hunie if you're not cute",
      "hunie.001a" => "So I'll be cute",
      "hunie.002" => "Hunies are all lustful",
      "hunie.002desc" => "You can't be a Hunie if you're not lustful",
      "hunie.002a" => "So I'll be lustful",
    )
  end

  def hunie_can_always_seduce!(node)
    fix_node = false # Do this after fixing children
    node.each do |key, val|
      if key == "has_focus" and val == "focus_seduction"
        fix_node = true
      end
      hunie_can_always_seduce!(val) if val.is_a?(PropertyList)
    end
    if fix_node
      # More complex patching but generates better looking diffs
      # Maybe this should get API too?
      i = node.list.index{|key,val| key == "has_focus" and val == "focus_seduction"}
      node.instance_eval{@list}[i] = ["OR", PropertyList[
        "has_focus", "focus_seduction",
        "trait", "hunie",
      ]]
    end
  end

  def create_minimal_hunie_trait!
    create_mod_file! "common/traits/99_hunie_traits.txt", PropertyList[
      "hunie", PropertyList[
        "inherit_chance", 100,
      ],
    ]
    create_mod_file! "interface/hunie.gfx", PropertyList[
      "spriteTypes", PropertyList[
        "spriteType", PropertyList[
          "name", "GFX_trait_hunie",
          "texturefile", "gfx/traits/seductress.tga",
          "noOfFrames", 1,
          "norefcount", true,
          "effectFile", "gfx/FX/buttonstate.lua",
        ],
      ],
    ]
    localization!("hunie_trait",
      "hunie" => "Hunie",
      "hunie_desc" => "A total hunie",
    )
  end

  def create_hunie_trait!
    create_mod_file! "common/traits/99_hunie_traits.txt", PropertyList[
      "hunie", PropertyList[
        # "cannot_marry", true,
        # "fertility", 0.5,
        "sex_appeal_opinion", 30,
        "inherit_chance", 100,
      ],
    ]
    create_mod_file! "interface/hunie.gfx", PropertyList[
      "spriteTypes", PropertyList[
        "spriteType", PropertyList[
          "name", "GFX_trait_hunie",
          "texturefile", "gfx/traits/seductress.tga",
          "noOfFrames", 1,
          "norefcount", true,
          "effectFile", "gfx/FX/buttonstate.lua",
        ],
      ],
    ]
    localization!("hunie_trait",
      "hunie" => "Hunie",
      "hunie_desc" => "The character cannot marry and will forever date casually instead",
    )
    # Hunies can't marry, so being pregnant while not married is just fine
    patch_mod_file!("events/birth_events.txt") do |node|
      event = node.find_all("character_event").find{|ev| ev["id"] == 401}
      #event["trigger"].add! "NOT", PropertyList["trait", "hunie"]
      event["option"].delete "piety"
      event["option"].delete "prestige"
      event["option"].add! "if", PropertyList[
        "limit", PropertyList["NOT", PropertyList["trait", "hunie"]],
        "piety", -50,
        "prestige", -50,
      ]
    end
    # Hunies can seduce by their nature, so they can focus on anything they want
    # It could just mod everything in decisions/* and events/*
    %W[
      decisions/way_of_life_decisions.txt
      events/birth_events.txt
      events/wol_lover_events.txt
      events/wol_seduction_events.txt
    ].each do |path|
      patch_mod_file!(path) do |node|
        hunie_can_always_seduce!(node)
      end
    end
  end

  def no_russian!
    # Keep 3 separate East Slavic cultures
    patch_mod_file!("events/cm_culture_conversion_events.txt") do |node|
      node.delete_if{|key, val| key == "province_event" and val["id"] == "CM.11"}
    end
  end

  # Better fix would be make it something that happens sometimes, not every damn time
  def disable_abandon_iconoclasm_for_ai!
    patch_mod_file!("decisions/conversion_decisions.txt") do |node|
      node["decisions"]["renounce_iconoclasm"]["ai_will_do"]["factor"] = 0
    end
  end

  def king_level_titles
    @king_level_titles ||= begin
      titles  = @game.parse("common/landed_titles/landed_titles.txt")
      empires = titles.keys.grep(/\Ae_/)
      [titles, *empires.map{|e| titles[e]}].map(&:keys).flatten(1).grep(/\Ak_/).sort
    end
  end

  # Transferring vassal dukes under vassal kings is broken
  # Don't setup any other transfers as that's unnecessary
  # Can't handle custom titles etc.
  def setup_vassal_transfer!
    decisions = []
    # FROM - emperor
    # ROOT - duke vassal
    # PREV - king vassal (within holder_scope)
    king_level_titles.each do |k_title|
      # Oops, localization system doesn't support CK2 yet, just EU4 :-/
      # Anyway, there's probably some way to make it work with %codes% instead
      k_title_loc = k_title.sub(/\Ak_/, "").split("_").map(&:capitalize).join(" ")

      decisions << Property[
        "transfer_vassal_under_#{k_title}", PropertyList[
          "filter", "vassals",
          "ai_target_filter", "vassals",
          "from_potential", PropertyList[
            "tier", "emperor",
            "any_vassal", PropertyList["has_landed_title", k_title],
          ],
          "potential", PropertyList[
            "tier", "duke",
          ],
          "allow", PropertyList[
            "tier", "duke",
            "liege", PropertyList["character", "FROM"],
            # Neighbouring vassal king
            "any_realm_province", PropertyList[
              "any_neighbor_province", PropertyList[
                "has_owner", true,
                "holder_scope", PropertyList[
                  "OR", PropertyList[
                    "has_landed_title", k_title,
                    "any_liege", PropertyList["has_landed_title", k_title],
                  ],
                ],
              ],
            ],
          ],
          "effect", PropertyList[
            k_title, PropertyList[
              "holder_scope", PropertyList[
                "ROOT", PropertyList[
                  "set_defacto_liege", "PREV",
                ],
                "opinion", PropertyList[
                  "modifier", "opinion_vassal_transfer",
                  "who", "liege",
                  "months", 120,
                ],
              ],
            ],
          ],
          "revoke_allowed", PropertyList["always", false],
          "ai_will_do", PropertyList["factor", 0],
        ],
      ]
      localization!("vassal_transfer_decisions",
        "transfer_vassal_under_#{k_title}" => "Transfer under #{k_title_loc}",
        "transfer_vassal_under_#{k_title}_desc" => "Make duke vassal of #{k_title_loc} instead of you directly",
      )
    end

    create_mod_file! "decisions/vassal_transfer_decisions.txt", PropertyList["targetted_decisions", PropertyList[*decisions]]
  end

  # As high as allowed by your technology
  def setup_sensible_ai_for_demesne_laws!
    patch_mod_file!("common/laws/demesne_laws.txt") do |node|
      laws_to_fix = %W[
        feudal_contract
        feudal_tax
        city_contract
        city_tax
        temple_contract
        temple_tax
        iqta_contract
        iqta_tax
      ]
      laws_to_fix.each do |law|
        node["laws"]["#{law}_0"]["ai_will_do"] = PropertyList[
          "factor", 0,
        ]
        node["laws"]["#{law}_1"]["ai_will_do"] = PropertyList[
          "factor", 1,
          "modifier", PropertyList["factor", 0, "has_law", "#{law}_2"],
          "modifier", PropertyList["factor", 0, "has_law", "#{law}_3"],
        ]
        node["laws"]["#{law}_2"]["ai_will_do"] = PropertyList[
          "factor", 1,
          "modifier", PropertyList["factor", 0, "has_law", "#{law}_3"],
        ]
        node["laws"]["#{law}_3"]["ai_will_do"] = PropertyList[
          "factor", 1,
        ]
      end
    end
  end

  def allow_everyone_river_access!
    patch_mod_file!("common/religions/00_religions.txt") do |node|
      node.each do |group_name, group|
        group.each do |religion_name, religion|
          next unless religion.is_a?(PropertyList)
          religion["allow_rivermovement"] = true
        end
      end
    end
  end

  def disable_fucking_hints!
    patch_mod_file!("common/hints.txt") do |node|
      node.each do |name, hint|
        hint.delete "sticky"
      end
    end
  end

  # Because it's a portage, only use with allow_everyone_river_access!
  def suez_canal!
    # 1382 - Gulf of Suez
    #  939 - Nile Delta
    #  789 - Pelusia
    patch_file!("map/adjacencies.csv", reencode: "iso-8859-1") do |content|
      [
        content,
        "939;1382;portage;789;-1;-1;-1;-1;Suez Canal",
      ].join("\r\n")
    end
    # Merge both oceans
    patch_mod_file!("map/default.map") do |map|
      map.delete_if{|k,v|
        k == "ocean_region" and v == PropertyList["sea_zones", [5, 6, 7, 8]]
      }
      map["ocean_region"]["sea_zones"] = [1,2,3,4,5,6,7,8]
    end
  end

  # Experimental, but this should allow cheap nomad->tribal->feudal transition
  # instead of paying ridiculous amounts of money for direct nomad->feudal
  def everyone_can_build_tribes!
    patch_mod_files!("common/governments/*.txt") do |node|
      node.each do |_, govs|
        govs.each do |name, gov|
          gov["can_build_tribal"] = true unless name == "nomadic_government"
        end
      end
    end
  end

  def universal_hate!
    patch_mod_file!("common/traits/00_traits.txt") do |node|
      node.each do |name, trait|
        if trait["education"]
          trait["general_opinion"] = -1000
        end
      end
    end
  end

  def divine_blood_full_fertility!
    override_defines_lua!("divine_blood",
      "NReligion.DIVINE_BLOOD_FERTILITY_MULT" => 1.0,
    )
  end

  # If this had a timeout it would be fine, but it's ridiculous lasting forever
  def no_foreign_conqueror_penalty!
    patch_mod_file!("common/opinion_modifiers/00_opinion_modifiers.txt") do |node|
      node["opinion_foreign_conqueror"].delete "opinion"
    end
  end

  def increase_vassal_limit!
    # The entire mechanic is dumb - it either does nothing
    # (short of preventing North Korea mode)
    # or is ridiculously punishing - and unlike with demesne limit
    # there's no reasonable workaround
    override_defines_lua!("vassal_limit",
      "NDiplomacy.VASSAL_LIMIT_DUKE_MULT" => 25.0,
      "NDiplomacy.VASSAL_LIMIT_KING_MULT" => 50.0,
      "NDiplomacy.VASSAL_LIMIT_EMPEROR_MULT" => 100.0,
      "NDiplomacy.VASSAL_LIMIT_GREAT_DUKE_BONUS" => 15.0,
    )
  end

  def increase_trade_post_limit!
    # Retinues and mercs got nerfed hard, why not keep at least this high?
    patch_mod_files!("common/buildings/00_buildings.txt") do |node|
      node["family_palace"]["fp_mansion_1"]["max_tradeposts"] = 10
      node["family_palace"]["fp_mansion_2"]["max_tradeposts"] = 10
      node["family_palace"]["fp_mansion_3"]["max_tradeposts"] = 10
      node["family_palace"]["fp_mansion_4"]["max_tradeposts"] = 10
    end
    override_defines_lua!("trade_posts",
      "NEconomy.MAX_TRADE_POSTS_BASE" => 10,
    )
  end

  def show_all_wars_on_map!
    patch_mod_files!("common/cb_types/*.txt") do |node|
      node.each do |name, cb|
        cb.delete("display_on_map")
      end
    end
  end

  def allow_feasts_at_minor_wars!
    # Optimal way would be to allow them in case of minor wars
    # (like being secondary partner, or peasant revolt)
    # but no major war, but for now let's just do this
    #
    # Hard to say in how many other places this needs to be updated
    # Diwali events seem to be checking if vassals are at war,
    # and if we are then all of them will be etc.
    # Oh well

    feasts = [
      "feast_0",
      "summer_fair",
      "hold_grand_hunt",
      "hold_tiger_hunt",
      "catholic_pilgrimage",
      "go_on_hajj",
      "observe_ramadan",
      "hold_nerge",
      "hold_blot",
      "hold_ukon_juhla",
      "hold_uzgavenes",
      "hold_jarilo",
      "celebrate_passover",
      "hold_diwali_feast_hindu",
      "hold_diwali_feast_buddhist",
      "hold_diwali_feast_jain",
      "hold_diwali_feast_kali_puja",
      "hold_zun_feast",
      "hold_a_epic_tournament",
      "hold_a_furusiyya",
      "hold_nomad_wargames",
    ]

    patch_mod_files!("decisions/*.txt") do |node|
      node.each do |category, decisions|
        next unless category == "decisions"
        decisions.each do |name, decision|
          next unless feasts.include?(name)
          next unless decision["allow"]["war"] == false
          decision["allow"].delete_if{|k,v| [k,v] == ["war", false]}
        end
      end
    end

    patch_mod_files!("events/*.txt") do |node|
      node.each do |category, event|
        next unless event["trigger"]
        next unless event["trigger"]["has_character_modifier"] == "holding_large_feast" or
                    event["trigger"]["has_character_modifier"] == "holding_grand_hunt"

        if event["trigger"]["war"] == false
          event["trigger"].delete_if{|k,v| [k,v] == ["war", false]}
        elsif event["trigger"]["war"] == true
          raise unless event["id"] == 72112 or event["id"] == 36089
        end
      end
      # 72112 - cancel feast because war
      # 36089 - cancel hunt because war
      node.delete_if{|c,e| e["id"] == 72112 or e["id"] == 36089}
    end
  end

  def become_republic_decision!
    create_mod_file! "decisions/feudal_to_republic.txt", PropertyList[
       "settlement_decisions", PropertyList[
        "feudal_adopt_republicanism", PropertyList[
          "filter", "sub_realm_owned",
          "ai_target_filter", "sub_realm_owned",
          "from_potential", PropertyList[
            "ai", false,
            "is_feudal", true,
            "is_female", false,
          ],
          "potential", PropertyList[
            "holding_type", "city",
            "capital_scope", PropertyList["port", true],
            "holder_scope", PropertyList["OR", PropertyList[
              "character", "FROM",
              "AND", PropertyList["any_liege", PropertyList["character", "FROM"]],
            ]],
          ],
          "allow", PropertyList[
            "OR", PropertyList[
              "is_capital", true,
              "capital_scope", PropertyList["holder_scope", PropertyList["character", "FROM"]],
            ],
            "has_siege", false,
            "FROM", PropertyList[
              # "independent", true,
              "war", false,
            ],
          ],
          "effect", PropertyList[
            "if", PropertyList[
              "limit", PropertyList["NOT", PropertyList["holder", "FROM"]],
              "usurp_title", "FROM",
            ],
            "if", PropertyList[
              "limit", PropertyList["is_capital", false],
              "make_capital_holding", true,
            ],
            "FROM", PropertyList[
              "capital", "PREV",
              "create_family_palace", true,
              "set_government_type", "merchant_republic_government",
              "wealth", 500,
            ],
          ],
          "revoke_allowed", PropertyList["always", false],
          "ai_will_do", PropertyList["factor", 0],
        ]
      ]
    ]
  end

  # This is very speculative, no idea if it does anything or not
  # (unlike let's say law changes which are pretty proven)
  def rebalance_faction_priorities!
    # AI faction choices drastically affect how things develop.
    # Rebalancing faction priorities can lead to much more interesting choices
    patch_mod_file!("common/objectives/00_factions.txt") do |node|
      # Not allowed unless Germanic culture
      # It would probably be better to disallow this succession type otherwise
      node["faction_succ_feudal_elective"]["potential"].add! Property::OR[
        "culture_group", "north_germanic",
        "culture_group", "central_germanic",
        "culture_group", "west_germanic",
      ]
      # Allow elective->gavelkind.
      # I hate elective all over the place, create some counterbalance to it
      node["faction_succ_gavelkind"]["chance"].delete_if do |k,v|
        k == "modifier" and v["has_law"] == "succ_feudal_elective"
      end
      # Make nomads a more eager to split
      node["faction_independence"]["membership"].add! "modifier", PropertyList[
        "factor", 10,
        "is_nomadic", true,
      ]
      # Nomads OP, forcing them to go independent instead will weaken them
      node["faction_overthrow"]["potential"] = PropertyList["always", false]
    end
  end

  def allow_joining_all_wars!
    # Maybe it's ridiculous, maybe it's great, no way to tell except by testing
    patch_mod_file!("common/cb_types/00_cb_types.txt") do |node|
      node.each do |name, cb|
        cb["can_ask_to_join_war"] = true
      end
    end
  end

  def more_plots!
    # More republican plots for start
    # Should do more fun plots later
    patch_mod_file!("common/objectives/00_plots.txt") do |node|
      node["plot_seize_trade_post"]["allow"]["trade_post_owner"].delete Property[
        "num_of_trade_post_diff",
        PropertyList[ "character", "FROM", "value", 1],
      ]
      node["plot_seize_trade_post"]["potential"].delete "is_merchant_republic"
      # require 'pry'; binding.pry
      node["plot_seize_trade_post"]["allow"]["trade_post_owner"]["OR"].add! "de_facto_liege", "FROM"
    end
  end

  def dont_call_duke_kings_ever!
    # There's also a setting in common/governments/* but it doesn't seem to work
    patch_mod_files!("common/cultures/00_cultures.txt") do |node|
      node.each do |group_name, group|
        group.each do |name, culture|
          culture.delete "dukes_called_kings"
        end
      end
    end
  end

  # Start dates in extended timeline are bugged as hell,
  # but it's still better than nothing
  def extend_timeline!
    patch_mod_file!("common/defines.txt") do |node|
      node["start_date"] = Date.parse("769.1.1")
    end
  end

  # There seems to be no way to restore old functionality via defines.txt etc.
  # So recoded from scratch
  # AI should have access to it, but it's simpler to start with player-only code
  def old_style_banishment_decision!
    create_mod_file! "decisions/banish_traitor_decisions.txt", PropertyList["targetted_decisions",
      PropertyList["banish_traitor_decision", PropertyList[
        "filter", "court",
        "ai_target_filter", "court",
        "is_high_prio", true,
        "from_potential", PropertyList[
          "is_ruler", true,
          "ai", false,
        ],
        "potential", PropertyList[
          "host", PropertyList["character", "FROM"],
          "prisoner", true,
        ],
        "allow", PropertyList[
          "prisoner", true,
          "FROM", PropertyList["OR", PropertyList[
            "has_opinion_modifier", PropertyList[
              "who", "ROOT",
              "modifier", "opinion_traitor",
            ],
            "has_opinion_modifier", PropertyList[
              "who", "ROOT",
              "modifier", "opinion_rebel_traitor",
            ],
            "has_opinion_modifier", PropertyList[
              "who", "ROOT",
              "modifier", "opinion_dishonorable",
            ],
          ]],
        ],
        "effect", PropertyList[
          "prisoner", false,
          "FROM", PropertyList[
            "remove_opinion", PropertyList[
              "who", "ROOT",
              "modifier", "opinion_traitor",
            ],
            "remove_opinion", PropertyList[
              "who", "ROOT",
              "modifier", "opinion_rebel_traitor",
            ],
            "remove_opinion", PropertyList[
              "who", "ROOT",
              "modifier", "opinion_dishonorable",
            ],
          ],
          "FROM", PropertyList["wealth", "ROOT"],
          "clear_wealth", true,
          "any_demesne_title", PropertyList[
            "limit", PropertyList["controls_religion", false],
            "usurp_title", "FROM",
          ],
        ],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
    ]]]
    localization!("banish_traitor",
      "banish_traitor_decision" => "Banish traitor!",
      "banish_traitor_decision_desc" => "Banish traitor and take all their gold and lands"
    )
  end

  # Vanilla map is really really dumb
  # It would take a lot of work to make it sensible, so just some easy code
  def fix_de_jure_map!
    # patch_mod_file!("common/landed_titles/landed_titles.txt") do |node|
    #   require 'pry'; binding.pry
    # end
    patch_mod_file!("history/titles/k_italy.txt") do |node|
      node[Date.parse("867.1.1")] = PropertyList["de_jure_liege", "e_hre"]
      node.instance_eval{ @list.sort! }
    end
  end

  # Culture conversion has extremely strict restrictions,
  # enable it even when they're not met, at lower chance
  # This will increase total rate by a lot, as one silly province will bloke
  # conversion futher down
  def easier_culture_conversion!
    patch_mod_file!("events/culture_conversion_events.txt") do |node|
      node.find_all("province_event").each do |event|
        if event["id"] == 55000
          event["trigger"].delete_if{|k,v| k == "any_neighbor_province"}
          # Speed it up by 2x base
          event["mean_time_to_happen"]["months"] /= 2
          event["mean_time_to_happen"].add! "modifier", PropertyList[
            "factor", 4.0,
            # Convert only if same culture as neighbouring province and its owner
            # This was hard requirement, make it just 4x slower if not met
            "NOT", PropertyList[
              "any_neighbor_province", PropertyList[
                "has_owner", true,
                "ROOT", PropertyList["owner", PropertyList["culture", "PREVPREV"]],
                "owner", PropertyList["ROOT", PropertyList["owner", PropertyList["culture", "PREVPREV"]]],
              ],
            ],
          ]
        elsif event["id"] == 55001
          # Conquest culture capital conversion. Just speed it up a bit.
          event["mean_time_to_happen"]["months"] /= 2
        end
      end
    end
  end

  # yields parent of node
  def deep_search(node, path=[], &blk)
    node.each do |key, val|
      if val.is_a?(PropertyList)
        deep_search(val, [*path, key], &blk)
      end
      yield(node, [*path, key])
    end
  end

  def easier_title_creation!
    patch_mod_file!("common/landed_titles/landed_titles.txt") do |titles|
      # No idea what it even does, other than screwing with setting up vassal Hungary
      # when it gets accidentally destroyed
      titles["e_carpathia"]["k_hungary"]["allow"] = PropertyList["always", true]

      deep_search(titles) do |node, path|
        next unless path[-1] == "allow"
        allow = node["allow"]
        title = path[-2]
        # These are generally sensible
        next if allow == PropertyList["always", false]
        next if allow == PropertyList["always", true]
        next if allow == PropertyList["is_republic", true]
        next if node["controls_religion"]
        next if node["mercenary"]

        # AI not being allowed to create title is really silly
        # especially in shattered world style games
        if allow["hidden_tooltip"] and
           allow["hidden_tooltip"]["OR"] and
           allow["hidden_tooltip"]["OR"]["ai"] == false
          allow.delete "hidden_tooltip"
          node["allow"] = PropertyList["always", true] if allow.empty?
          next
        end
      end
    end
  end

  # They are just way too silly, slowing down their reinforcements
  # will at least let them be weak sometimes instead of instantly rebounding
  # to full strength
  def nerf_nomads!
    override_defines_lua!("nerf_nomads",
      "NNomad.HORDE_REINFORCE_MULTIPLIER" => 1,
    )
  end

  def build_mod_files!
    ### General fixes:
    no_dynastic_country_names!
    allow_any_number_of_different_holding_types!
    allow_intermarriage!
    fix_gavelkind!
    reset_ruler_designer!
    reduce_wrong_gov_type_penalties!
    seduce_any_religion!
    cognatic_for_most_cultures!
    preserve_culture_buildings!
    pagans_can_go_feudal!
    add_dynastic_decisions!
    setup_sensible_imporatnt_decisions_list!
    setup_vassal_transfer!
    setup_sensible_ai_for_demesne_laws!
    fast_de_jure_drift!
    allow_everyone_river_access!
    disable_fucking_hints!
    suez_canal!
    disable_diplomatic_range_limit!
    no_foreign_conqueror_penalty!
    increase_vassal_limit!
    increase_trade_post_limit!
    show_all_wars_on_map!
    allow_feasts_at_minor_wars!
    become_republic_decision!
    no_multiple_empires!
    more_plots!
    dont_call_duke_kings_ever!
    extend_timeline!
    old_style_banishment_decision!
    fix_de_jure_map!
    easier_culture_conversion!
    easier_title_creation!
    # TODO: de jure drift by title_decisions

    ### Specific things for specific campaign, kept for reference:
    # create_hunie_trait!
    # no_russian!
    # disable_abandon_iconoclasm_for_ai!
    # universal_hate!
    # remove_levy_nerfs!
    # everyone_can_build_tribes!
    # divine_blood_full_fertility!
    create_minimal_hunie_trait!
    # allow_heir_designation!
    rebalance_faction_priorities!
    allow_joining_all_wars!
    nerf_nomads!

    ### Completely obsolete in new patch
    ### (sadly new banishment system is completely broken, and this fix doesn't restore previous behaviour)
    # more_banishment_reasons!
  end
end

mb = CK2TweaksModBuilder.new(
  ParadoxGame.new(
    "source/ck2_2.4.3",
  ),
  "output/ck2tweaks"
)
mb.build!
