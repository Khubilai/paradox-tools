#!/usr/bin/env ruby

require_relative "../lib/paradox_mod_builder"

class CK2TweaksModBuilder < ParadoxModBuilder
  # Move to base?
  def override_defines_lua!(name, overrides)
    create_file!(
      "common/defines/#{name}.lua",
      overrides.map{|key, val| "NDefines.#{key} = #{val}\n"}.join
    )
  end

  def reset_ruler_designer!
    keys  = %W[
      COST_ATTRIB
      COST_SON
      COST_DAUGHTER
      COST_MARRIED
      COST_FERTILITY
      COST_HEALTH
      COST_MONTHLY_PRESTIGE
      COST_MONTHLY_PIETY
      COST_MONTHLY_WEALTH
      COST_GLOBAL_TAX
      COST_CHURCH_OPINION
      COST_SPOUCE_OPINION
      COST_SEXAPPEAL_OPINION
      COST_DYNASTY_OPINION
      COST_VASSAL_OPINION
      COST_LIEGE_OPINION
      COST_INFIDEL_OPINION
      COST_OPPOSITE_TRAIT_OPINION
      COST_SAME_TRAIT_OPINION
      COST_SAME_RELIGION_OPINION
      COST_AMBITION_OPINION
      COST_TRIBAL_OPINION
      COST_UNREFORMED_TRIBAL_OPINION
      COST_GENERAL_OPINION
      COST_MUSLIM_OPINION
      COST_JEWISH_OPINION
      COST_CHRISTIAN_OPINION
      COST_ZOROASTRIAN_OPINION
      COST_MORALE_OFFENCE
      COST_MORALE_DEFENCE
      COST_DEFENCE
    ]
    # Keep BASE_*, MAX_AGE
    override_defines_lua!("ruler_designer",
      Hash[keys.map{|key| ["NRulerDesigner.#{key}", 0] }]
    )
    patch_mod_files!("common/traits/*.txt") do |node|
      node.each do |name, trait|
        trait.delete "ruler_designer_cost"
      end
    end
  end

  def fix_gavelkind!
    # Bonus is not applied correctly and is far less than 30% claimed
    # Increase it to balance things out a bit
    override_defines_lua!("gavelkind",
      "NDiplomacy.GAVELKIND_MAX_SIZE_BONUS" => "0.50"
    )
  end

  def reduce_wrong_gov_type_penalties!
    # This punishes feudalizing tribals way too much
    override_defines_lua!("wrong_gov_type",
      "NCharacter.WRONG_GOV_FORM_TAX_MOD"  => -0.50,
      "NCharacter.WRONG_GOV_FORM_LEVY_MOD" => -0.50,
    )
  end

  def allow_any_number_of_different_holding_types!
    # A nerf without exploit
    override_defines_lua!("max_counties_in_realm",
      "NTitle.MAX_REPUBLIC_COUNTIES_IN_REALM"  => 1.0,
      "NTitle.MAX_THEOCRACY_COUNTIES_IN_REALM" => 1.0,
    )
  end

  def take_money_from_banished_landed_characters!
    # That's not even particularly gamey
    override_defines_lua!("banish_take_wealth",
      "NDiplomacy.BANISH_TAKE_WEALTH_PERCENTAGE_LANDED" => 1,
    )
  end

  def disable_diplomatic_range_limit!
    override_defines_lua!("diplomatic_distance",
      "NDiplomacy.MAX_DIPLO_DISTANCE" => 10000,
    )
  end

  def remove_levy_nerfs!
    # This break feudal character of the game
    override_defines_lua!("levy_nerf",
      "NMilitary.REBEL_LEADER_MINIMUM_LIEGE_LEVY_MULT"  => 1,
      "NMilitary.CAPITAL_COUNTY_VASSAL_COUNT_LEVY_MULT" => 1,
      "NMilitary.CAPITAL_COUNTY_VASSAL_LEVY_MULT"       => 1,
      "NMilitary.CAPITAL_COUNTY_LEVY_MULT"              => 1,
      "NMilitary.CAPITAL_COUNTY_LIEGE_LEVY_MULT"        => 1,
      "NMilitary.CAPITAL_DUCHY_VASSAL_LEVY_MULT"        => 1,
      "NMilitary.CAPITAL_DUCHY_LEVY_MULT"               => 1,
      "NMilitary.CAPITAL_DUCHY_LIEGE_LEVY_MULT"         => 1,
      "NMilitary.CAPITAL_KINGDOM_LEVY_MULT"             => 1,
      "NMilitary.CAPITAL_KINGDOM_LIEGE_LEVY_MULT"       => 1,
      "NMilitary.CAPITAL_EMPIRE_LEVY_MULT"              => 1,
      "NMilitary.CAPITAL_EMPIRE_LIEGE_LEVY_MULT"        => 1,
      "NMilitary.OUTSIDE_LEVY_MULT"                     => 1,
      "NMilitary.OUTSIDE_LIEGE_LEVY_MULT"               => 1,
    )
  end

  def no_dynastic_country_names!
    patch_mod_files!("common/cultures/*.txt") do |node|
      node.each do |group_name, group|
        group.each do |culture_name, culture|
          next if culture_name == "graphical_culture"
          next if culture_name == "second_graphical_culture"
          culture.delete("dynasty_title_names")
        end
      end
    end
  end

  def allow_intermarriage!
    patch_mod_file!("common/religions/00_religions.txt") do |node|
      religion_groups = node.keys
      node.each do |group_name, group|
        group.each do |religion_name, religion|
          next unless religion.is_a?(PropertyList)
          religion.delete("intermarry")
          religion_groups.each do |g|
            religion.add! "intermarry", g
          end
        end
      end
    end
  end

  def allow_heir_designation!
    patch_mod_file!("common/religions/00_religions.txt") do |node|
      node.each do |group_name, group|
        next if group_name == "muslim"
        group.each do |religion_name, religion|
          next unless religion.is_a?(PropertyList)
          religion["has_heir_designation"] = true
        end
      end
    end
  end

  def pagans_can_go_feudal!
    # Otherwise AI never will
    patch_mod_file!("decisions/realm_decisions.txt") do |node|
      %W[
        convert_to_feudalism_indep
        convert_to_feudalism_vassal
        convert_to_republic_indep
      ].each do |decision|
        node["decisions"][decision]["allow"].delete_if{|k,v| k == "custom_tooltip"}
      end
    end
  end

  def more_banishment_reasons!
    patch_mod_file!("common/opinion_modifiers/00_opinion_modifiers.txt") do |node|
      %W[
        opinion_traitor
        opinion_rebel_traitor
        opinion_regicide_traitor
        opinion_witch
        opinion_unfaithful_wife
        opinion_cuckolded
        opinion_charge_illegitimate
        opinion_charge_traitor
      ].each do |op|
        node[op].add! "banish_reason", true
      end
    end
  end

  def add_dynastic_decisions!
    # All these should be filtered etc.
    # Extremely basic functionality only
    decisions = PropertyList[
      "switch_to_spouse_dynasty", PropertyList[
        "filter", "spouse",
        "ai_target_filter", "spouse",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList["is_married", "FROM"],
        "allow", PropertyList["age", 16],
        "effect", PropertyList["FROM", PropertyList["dynasty", "ROOT"]],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ],
      "make_marriage_regular", PropertyList[
        "filter", "spouse",
        "ai_target_filter", "spouse",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList["is_married", "FROM"],
        "allow", PropertyList["age", 16],
        "effect", PropertyList["FROM", PropertyList["add_spouse", "ROOT"]],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ],
      "make_marriage_matrilineal", PropertyList[
        "filter", "spouse",
        "ai_target_filter", "spouse",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList["is_married", "FROM"],
        "allow", PropertyList["age", 16],
        "effect", PropertyList["FROM", PropertyList["add_spouse_matrilineal", "ROOT"]],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ],
      "educate_kin", PropertyList[
        "filter", "dynasty",
        "ai_target_filter", "dynasty",
        "from_potential", PropertyList["age", 16],
        "potential", PropertyList[
          "age", 6,
          Property::NOT["age", 16],
        ],
        # "allow", PropertyList[
          # "is_close_relative", "ROOT",
          # Property::NOT["guardian", "ROOT"],
        # ],
        "effect", PropertyList["set_guardian", "FROM"],
        "revoke_allowed", PropertyList["always", false],
        "ai_will_do", PropertyList["factor", 0],
      ]
    ]

    create_mod_file! "decisions/dynastic_decisions.txt", PropertyList["targetted_decisions", decisions]
    localization!("dynastic_decisions",
      "switch_to_spouse_dynasty" => "Swich to spouse's dynasty",
      "switch_to_spouse_dynasty_desc" => "Abandon your current family name, become part of spouse's dynasty",
      "make_marriage_regular" => "Make marriage regular",
      "make_marriage_regular_desc" => "All children will by of father's dynasty",
      "make_marriage_matrilineal" => "Make marriage matrilineal",
      "make_marriage_matrilineal_desc" => "All children will by of mother's dynasty",
      "educate_kin" => "Educate close kin",
      "educate_kin_desc" => "Can use even if beyond education limit",
    )
  end

  def cognatic_for_most_cultures!
    patch_mod_file!("common/laws/succession_laws.txt") do |node|
      node["gender_laws"]["true_cognatic_succession"].delete("allow")
    end
  end

  def setup_sensible_imporatnt_decisions_list!
    patch_mod_files!("decisions/*.txt") do |node|
      node.each do |category, decisions|
        next unless category == "decisions"
        decisions.each do |name, decision|
          time_specific  = !!(decision["allow"].to_s =~ /month|war/)
          focus_specific = !!(decision["potential"].to_s =~ /has_focus/)

          if ["ask_help_to_manage_titles", "conscript_merchant_ships"].include?(name)
            decision.delete "is_high_prio"
          elsif ["welcome_jews", "expel_jews", "borrow_money_jews"].include?(name) or
                time_specific or focus_specific
            decision.add! "is_high_prio", true
          elsif decision["is_high_prio"]
            # The rest are OK
          else
            # The rest are OK
          end
        end
      end
    end
  end

  def preserve_culture_buildings!
    patch_mod_files!("common/buildings/*.txt") do |node|
      node.each do |category, buildings|
        buildings.each do |name, building|
          next unless building["potential"] and building["potential"]["FROM"].to_s =~ /culture/
          culture_rules = building["potential"]["FROM"]

          if culture_rules.size == 1
            province_rule = Property[*culture_rules.list[0]]
          else
            province_rule = Property::AND[*culture_rules.list.flatten(1)]
          end

          building["potential"].delete "FROM"
          building["potential"].add! Property::OR[
            "FROM", culture_rules,
            province_rule,
            "FROMFROM", PropertyList["has_building", name],
          ]
        end
      end
    end
  end

  def tribal_buildings_for_prestige!
    patch_mod_files!("common/buildings/*.txt") do |node|
      node.each do |category, buildings|
        next unless category == "tribal"
        buildings.each do |name, building|
          if building["gold_cost"] and not building["port"]
            building.add! "prestige_cost", building["gold_cost"] * 2
            building.delete "gold_cost"
          elsif building["prestige_cost"]
            building["prestige_cost"] /= 2
          end
        end
      end
    end
  end

  # It is just ridiculously slow. This is probably too much, but worth trying.
  def faster_culture_conversion!
    patch_mod_file!("events/culture_conversion_events.txt") do |node|
      node.find_all("province_event").each do |event|
        next unless event["id"] == 55000 or event["id"] == 55001
        event["mean_time_to_happen"]["months"] /= 10
      end
    end
  end

  def fast_de_jure_drift!
    override_defines_lua!("de_jure_drift",
      "NTitle.DE_JURE_ASSIMILATION_YEARS" => 50,
      "NTitle.EMPIRE_DE_JURE_ASSIMILATION_YEARS" => 20,
    )
  end

  def seduce_any_religion!
    patch_mod_file!("decisions/way_of_life_decisions.txt") do |node|
      node["targetted_decisions"]["seduce_decision"]["allow"].delete "religion_group"
    end
  end

  # Crashes the game, would be interesting to debug
  def create_hunie_events!
    # All hunies are attractive
    # All hunies >16 are lustful
    create_mod_file! "events/hunie_events.txt", PropertyList[
      "character_event", PropertyList[
        "id", "hunie.001",
        "desc", "hunie.001desc",
        "picture", "GFX_evt_lovers",
        "border", "GFX_event_normal_frame_intrigue",
        "trigger", PropertyList[
          "trait", "hunie",
          "NOT", PropertyList["trait", "fair"],
        ],
        "mean_time_to_happen", PropertyList["months", 0],
        "option", PropertyList[
          "name", "hunie.001a",
          "add_trait", "fair",
        ],
      ],
      "character_event", PropertyList[
        "id", "hunie.002",
        "desc", "hunie.002desc",
        "picture", "GFX_evt_lovers",
        "border", "GFX_event_normal_frame_intrigue",
        "trigger", PropertyList[
          "trait", "hunie",
          "age", 16,
          "NOT", PropertyList["trait", "lustful"],
        ],
        "mean_time_to_happen", PropertyList["months", 0],
        "option", PropertyList[
          "name", "hunie.002a",
          "add_trait", "lustful",
        ],
      ],
    ]
    localization!("hunie_events",
      "hunie.001" => "Hunies are all cute",
      "hunie.001desc" => "You can't be a Hunie if you're not cute",
      "hunie.001a" => "So I'll be cute",
      "hunie.002" => "Hunies are all lustful",
      "hunie.002desc" => "You can't be a Hunie if you're not lustful",
      "hunie.002a" => "So I'll be lustful",
    )
  end

  def hunie_can_always_seduce!(node)
    fix_node = false # Do this after fixing children
    node.each do |key, val|
      if key == "has_focus" and val == "focus_seduction"
        fix_node = true
      end
      hunie_can_always_seduce!(val) if val.is_a?(PropertyList)
    end
    if fix_node
      # More complex patching but generates better looking diffs
      # Maybe this should get API too?
      i = node.list.index{|key,val| key == "has_focus" and val == "focus_seduction"}
      node.instance_eval{@list}[i] = ["OR", PropertyList[
        "has_focus", "focus_seduction",
        "trait", "hunie",
      ]]
    end
  end

  def create_minimal_hunie_trait!
    create_mod_file! "common/traits/99_hunie_traits.txt", PropertyList[
      "hunie", PropertyList[
        "inherit_chance", 100,
      ],
    ]
    create_mod_file! "interface/hunie.gfx", PropertyList[
      "spriteTypes", PropertyList[
        "spriteType", PropertyList[
          "name", "GFX_trait_hunie",
          "texturefile", "gfx/traits/seductress.tga",
          "noOfFrames", 1,
          "norefcount", true,
          "effectFile", "gfx/FX/buttonstate.lua",
        ],
      ],
    ]
    localization!("hunie_trait",
      "hunie" => "Hunie",
      "hunie_desc" => "A total hunie",
    )
  end

  def create_hunie_trait!
    create_mod_file! "common/traits/99_hunie_traits.txt", PropertyList[
      "hunie", PropertyList[
        # "cannot_marry", true,
        # "fertility", 0.5,
        "sex_appeal_opinion", 30,
        "inherit_chance", 100,
      ],
    ]
    create_mod_file! "interface/hunie.gfx", PropertyList[
      "spriteTypes", PropertyList[
        "spriteType", PropertyList[
          "name", "GFX_trait_hunie",
          "texturefile", "gfx/traits/seductress.tga",
          "noOfFrames", 1,
          "norefcount", true,
          "effectFile", "gfx/FX/buttonstate.lua",
        ],
      ],
    ]
    localization!("hunie_trait",
      "hunie" => "Hunie",
      "hunie_desc" => "The character cannot marry and will forever date casually instead",
    )
    # Hunies can't marry, so being pregnant while not married is just fine
    patch_mod_file!("events/birth_events.txt") do |node|
      event = node.find_all("character_event").find{|ev| ev["id"] == 401}
      #event["trigger"].add! "NOT", PropertyList["trait", "hunie"]
      event["option"].delete "piety"
      event["option"].delete "prestige"
      event["option"].add! "if", PropertyList[
        "limit", PropertyList["NOT", PropertyList["trait", "hunie"]],
        "piety", -50,
        "prestige", -50,
      ]
    end
    # Hunies can seduce by their nature, so they can focus on anything they want
    # It could just mod everything in decisions/* and events/*
    %W[
      decisions/way_of_life_decisions.txt
      events/birth_events.txt
      events/wol_lover_events.txt
      events/wol_seduction_events.txt
    ].each do |path|
      patch_mod_file!(path) do |node|
        hunie_can_always_seduce!(node)
      end
    end
  end

  def no_russian!
    # Keep 3 separate East Slavic cultures
    patch_mod_file!("events/cm_culture_conversion_events.txt") do |node|
      node.delete_if{|key, val| key == "province_event" and val["id"] == "CM.11"}
    end
  end

  # Better fix would be make it something that happens sometimes, not every damn time
  def disable_abandon_iconoclasm_for_ai!
    patch_mod_file!("decisions/conversion_decisions.txt") do |node|
      node["decisions"]["renounce_iconoclasm"]["ai_will_do"]["factor"] = 0
    end
  end

  def king_level_titles
    @king_level_titles ||= begin
      titles  = @game.parse("common/landed_titles/landed_titles.txt")
      empires = titles.keys.grep(/\Ae_/)
      [titles, *empires.map{|e| titles[e]}].map(&:keys).flatten(1).grep(/\Ak_/).sort
    end
  end

  # Transferring vassal dukes under vassal kings is broken
  # Don't setup any other transfers as that's unnecessary
  # Can't handle custom titles etc.
  def setup_vassal_transfer!
    decisions = []
    # FROM - emperor
    # ROOT - duke vassal
    # PREV - king vassal (within holder_scope)
    king_level_titles.each do |k_title|
      # Oops, localization system doesn't support CK2 yet, just EU4 :-/
      # Anyway, there's probably some way to make it work with %codes% instead
      k_title_loc = k_title.sub(/\Ak_/, "").split("_").map(&:capitalize).join(" ")

      decisions << Property[
        "transfer_vassal_under_#{k_title}", PropertyList[
          "filter", "vassals",
          "ai_target_filter", "vassals",
          "from_potential", PropertyList[
            "tier", "emperor",
            "any_vassal", PropertyList["has_landed_title", k_title],
          ],
          "potential", PropertyList[
            "tier", "duke",
          ],
          "allow", PropertyList[
            "tier", "duke",
            "liege", PropertyList["character", "FROM"],
            # Neighbouring vassal king
            "any_realm_province", PropertyList[
              "any_neighbor_province", PropertyList[
                "has_owner", true,
                "holder_scope", PropertyList[
                  "OR", PropertyList[
                    "has_landed_title", k_title,
                    "any_liege", PropertyList["has_landed_title", k_title],
                  ],
                ],
              ],
            ],
          ],
          "effect", PropertyList[
            k_title, PropertyList[
              "holder_scope", PropertyList[
                "ROOT", PropertyList[
                  "set_defacto_liege", "PREV",
                ],
                "opinion", PropertyList[
                  "modifier", "opinion_vassal_transfer",
                  "who", "liege",
                  "months", 120,
                ],
              ],
            ],
          ],
          "revoke_allowed", PropertyList["always", false],
          "ai_will_do", PropertyList["factor", 0],
        ],
      ]
      localization!("vassal_transfer_decisions",
        "transfer_vassal_under_#{k_title}" => "Transfer under #{k_title_loc}",
        "transfer_vassal_under_#{k_title}_desc" => "Make duke vassal of #{k_title_loc} instead of you directly",
      )
    end

    create_mod_file! "decisions/vassal_transfer_decisions.txt", PropertyList["targetted_decisions", PropertyList[*decisions]]
  end

  # As high as allowed by your technology
  def setup_sensible_ai_for_demesne_laws!
    patch_mod_file!("common/laws/demesne_laws.txt") do |node|
      laws_to_fix = %W[
        feudal_contract
        feudal_tax
        city_contract
        city_tax
        temple_contract
        temple_tax
        iqta_contract
        iqta_tax
      ]
      laws_to_fix.each do |law|
        node["laws"]["#{law}_0"]["ai_will_do"] = PropertyList[
          "factor", 0,
        ]
        node["laws"]["#{law}_1"]["ai_will_do"] = PropertyList[
          "factor", 1,
          "modifier", PropertyList["factor", 0, "has_law", "#{law}_2"],
          "modifier", PropertyList["factor", 0, "has_law", "#{law}_3"],
        ]
        node["laws"]["#{law}_2"]["ai_will_do"] = PropertyList[
          "factor", 1,
          "modifier", PropertyList["factor", 0, "has_law", "#{law}_3"],
        ]
        node["laws"]["#{law}_3"]["ai_will_do"] = PropertyList[
          "factor", 1,
        ]
      end
    end
  end

  def allow_everyone_river_access!
    patch_mod_file!("common/religions/00_religions.txt") do |node|
      node.each do |group_name, group|
        group.each do |religion_name, religion|
          next unless religion.is_a?(PropertyList)
          religion["allow_rivermovement"] = true
        end
      end
    end
  end

  def disable_fucking_hints!
    patch_mod_file!("common/hints.txt") do |node|
      node.each do |name, hint|
        hint.delete "sticky"
      end
    end
  end

  # Because it's a portage, only use with allow_everyone_river_access!
  def suez_canal!
    # 1382 - Gulf of Suez
    #  939 - Nile Delta
    #  789 - Pelusia
    patch_file!("map/adjacencies.csv", reencode: "iso-8859-1") do |content|
      [
        content,
        "939;1382;portage;789;-1;-1;-1;-1;Suez Canal",
      ].join("\r\n")
    end
    # Merge both oceans
    patch_mod_file!("map/default.map") do |map|
      map.delete_if{|k,v|
        k == "ocean_region" and v == PropertyList["sea_zones", [5, 6, 7, 8]]
      }
      map["ocean_region"]["sea_zones"] = [1,2,3,4,5,6,7,8]
    end
  end

  # Experimental, but this should allow cheap nomad->tribal->feudal transition
  # instead of paying ridiculous amounts of money for direct nomad->feudal
  def everyone_can_build_tribes!
    patch_mod_files!("common/governments/*.txt") do |node|
      node.each do |_, govs|
        govs.each do |name, gov|
          gov["can_build_tribal"] = true unless name == "nomadic_government"
        end
      end
    end
  end

  def universal_hate!
    patch_mod_file!("common/traits/00_traits.txt") do |node|
      node.each do |name, trait|
        if trait["education"]
          trait["general_opinion"] = -1000
        end
      end
    end
  end

  def divine_blood_full_fertility!
    override_defines_lua!("divine_blood",
      "NReligion.DIVINE_BLOOD_FERTILITY_MULT" => 1.0,
    )
  end

  # If this had a timeout it would be fine, but it's ridiculous lasting forever
  def no_foreign_conqueror_penalty!
    patch_mod_file!("common/opinion_modifiers/00_opinion_modifiers.txt") do |node|
      node["opinion_foreign_conqueror"].delete "opinion"
    end
  end

  def increase_vassal_limit!
    # The entire mechanic is dumb - it either does nothing
    # (short of preventing North Korea mode)
    # or is ridiculously punishing - and unlike with demesne limit
    # there's no reasonable workaround
    override_defines_lua!("vassal_limit",
      "NDiplomacy.VASSAL_LIMIT_DUKE_MULT" => 25.0,
      "NDiplomacy.VASSAL_LIMIT_KING_MULT" => 50.0,
      "NDiplomacy.VASSAL_LIMIT_EMPEROR_MULT" => 100.0,
      "NDiplomacy.VASSAL_LIMIT_GREAT_DUKE_BONUS" => 15.0,
    )
  end

  def show_all_wars_on_map!
    patch_mod_files!("common/cb_types/*.txt") do |node|
      node.each do |name, cb|
        cb.delete("display_on_map")
      end
    end
  end

  def allow_feasts_at_minor_wars!
    # Optimal way would be to allow them in case of minor wars
    # (like being secondary partner, or peasant revolt)
    # but no major war, but for now let's just do this
    #
    # Hard to say in how many other places this needs to be updated
    # Diwali events seem to be checking if vassals are at war,
    # and if we are then all of them will be etc.
    # Oh well

    feasts = [
      "feast_0",
      "summer_fair",
      "hold_grand_hunt",
      "hold_tiger_hunt",
      "catholic_pilgrimage",
      "go_on_hajj",
      "observe_ramadan",
      "hold_nerge",
      "hold_blot",
      "hold_ukon_juhla",
      "hold_uzgavenes",
      "hold_jarilo",
      "celebrate_passover",
      "hold_diwali_feast_hindu",
      "hold_diwali_feast_buddhist",
      "hold_diwali_feast_jain",
      "hold_diwali_feast_kali_puja",
      "hold_zun_feast",
      "hold_a_epic_tournament",
      "hold_a_furusiyya",
      "hold_nomad_wargames",
    ]

    patch_mod_files!("decisions/*.txt") do |node|
      node.each do |category, decisions|
        next unless category == "decisions"
        decisions.each do |name, decision|
          next unless feasts.include?(name)
          next unless decision["allow"]["war"] == false
          decision["allow"].delete_if{|k,v| [k,v] == ["war", false]}
        end
      end
    end

    patch_mod_files!("events/*.txt") do |node|
      node.each do |category, event|
        next unless event["trigger"]
        next unless event["trigger"]["has_character_modifier"] == "holding_large_feast" or
                    event["trigger"]["has_character_modifier"] == "holding_grand_hunt"

        if event["trigger"]["war"] == false
          event["trigger"].delete_if{|k,v| [k,v] == ["war", false]}
        elsif event["trigger"]["war"] == true
          raise unless event["id"] == 72112 or event["id"] == 36089
        end
      end
      # 72112 - cancel feast because war
      # 36089 - cancel hunt because war
      node.delete_if{|c,e| e["id"] == 72112 or e["id"] == 36089}
    end
  end

  def build_mod_files!
    ### General fixes:
    no_dynastic_country_names!
    allow_any_number_of_different_holding_types!
    allow_intermarriage!
    allow_heir_designation!
    fix_gavelkind!
    reset_ruler_designer!
    reduce_wrong_gov_type_penalties!
    seduce_any_religion!
    cognatic_for_most_cultures!
    preserve_culture_buildings!
    pagans_can_go_feudal!
    add_dynastic_decisions!
    setup_sensible_imporatnt_decisions_list!
    setup_vassal_transfer!
    setup_sensible_ai_for_demesne_laws!
    fast_de_jure_drift!
    allow_everyone_river_access!
    disable_fucking_hints!
    suez_canal!
    disable_diplomatic_range_limit!
    no_foreign_conqueror_penalty!
    increase_vassal_limit!
    show_all_wars_on_map!
    allow_feasts_at_minor_wars!
    # TODO: de jure drift by title_decisions

    ### Specific things for specific campaign, kept for reference:
    # create_hunie_trait!
    # no_russian!
    # disable_abandon_iconoclasm_for_ai!
    # faster_culture_conversion!
    # universal_hate!
    # remove_levy_nerfs!
    everyone_can_build_tribes!
    divine_blood_full_fertility!
    create_minimal_hunie_trait!

    ### Completely obsolete in new patch
    ### (sadly new banishment system is completely broken, and this fix doesn't restore previous behaviour)
    # tribal_buildings_for_prestige!
    # take_money_from_banished_landed_characters!
    # more_banishment_reasons!
  end
end

mb = CK2TweaksModBuilder.new(
  ParadoxGame.new(
    "source/ck2_2.4.2",
  ),
  "output/ck2tweaks"
)
mb.build!
